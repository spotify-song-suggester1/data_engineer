# -*- coding: utf-8 -*-
"""Copy of SpotifyBW.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1tAyzbtgvsCwo9zmz9uUmhcSUClg4-wcx
"""

from pandas.io.json import json_normalize
import pandas as pd
import json as json
import requests
import base64
import datetime
from urllib.parse import urlencode
import time
from random_word import RandomWords
from os import getenv
# Readquitme: https://pypi.org/project/Random-Word/

client_id = getenv('CLIENT_ID')
client_secret = getenv('CLIENT_SECRET')


class SpotifyAPI(object):
    access_token = None
    access_token_expires = datetime.datetime.now()
    access_token_did_expire = True
    client_id = None
    client_secret = None
    token_url = "https://accounts.spotify.com/api/token"

    def __init__(self, client_id, client_secret, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.client_id = client_id
        self.client_secret = client_secret

    def get_client_credentials(self):
        """
        Returns a base64 encoded string
        """
        client_id = self.client_id
        client_secret = self.client_secret
        if client_secret == None or client_id == None:
            raise Exception("You must set client_id and client_secret")
        client_creds = f"{client_id}:{client_secret}"
        client_creds_b64 = base64.b64encode(client_creds.encode())
        return client_creds_b64.decode()

    def get_token_headers(self):
        client_creds_b64 = self.get_client_credentials()
        return {
            "Authorization": f"Basic {client_creds_b64}"
        }

    def get_token_data(self):
        return {
            "grant_type": "client_credentials"
        }

    def perform_auth(self):
        token_url = self.token_url
        token_data = self.get_token_data()
        token_headers = self.get_token_headers()
        r = requests.post(token_url, data=token_data, headers=token_headers)
        if r.status_code not in range(200, 299):
            raise Exception("Could not authenticate client.")
            # return False
        data = r.json()
        now = datetime.datetime.now()
        access_token = data['access_token']
        expires_in = data['expires_in']  # seconds
        expires = now + datetime.timedelta(seconds=expires_in)
        self.access_token = access_token
        self.access_token_expires = expires
        self.access_token_did_expire = expires < now
        return True

    def get_access_token(self):
        token = self.access_token
        expires = self.access_token_expires
        now = datetime.datetime.now()
        if expires < now:
            self.perform_auth()
            return self.get_access_token()
        elif token == None:
            self.perform_auth()
            return self.get_access_token()
        return token

    def get_resource_header(self):
        access_token = self.get_access_token()
        headers = {
            "Authorization": f"Bearer {access_token}"
        }
        return headers
    
    
    
    # Need to add get_resources, so that we don't get rate-limited 
    # (as in curl -X "GET" "https://api.spotify.com/v1/tracks?ids=7ouMYWpwJ422jRcDASZB7P%2C4VqPOruhp5EdPBeR92t6lQ%2C2takcwOaAZWiXQijPHIx7B&market=ES" -H "Accept: application/json" -H "Content-Type: application/json" -H "Authorization: Bearer ")

    # So I changed this method accordingly
    def get_resources(self, lookup_parameters, lookup_parameter_type="ids",  resource_type='tracks', version='v1'):
        endpoint = f"https://api.spotify.com/{version}/{resource_type}?{lookup_parameter_type}={lookup_parameters}"
        headers = self.get_resource_header()
        r = requests.get(endpoint, headers=headers)
        if r.status_code not in range(200, 299):
            return {}
        return r.json()

    def get_resource(self, lookup_id, resource_type='albums', version='v1'):
        endpoint = f"https://api.spotify.com/{version}/{resource_type}/{lookup_id}"
        headers = self.get_resource_header()
        r = requests.get(endpoint, headers=headers)
        if r.status_code not in range(200, 299):
            return {}
        return r.json()

    def get_album(self, _id):
        return self.get_resource(_id, resource_type='albums')

    def get_artist(self, _id):
        return self.get_resource(_id, resource_type='artists')

    def base_search(self, query_params):  # type
        headers = self.get_resource_header()
        endpoint = "https://api.spotify.com/v1/search"
        lookup_url = f"{endpoint}?{query_params}"
        r = requests.get(lookup_url, headers=headers)
        if r.status_code not in range(200, 299):
            return {}
        return r.json()

    def search(self, query=None, operator=None, operator_query=None, search_type='artist'):
        if query == None:
            raise Exception("A query is required.")
        if isinstance(query, dict):
            query = " ".join([f"{k}:{v}" for k, v in query.items()])
        if operator != None and operator_query != None:
            if operator.lower() == "or" or operator.lower() == "not":
                operator = operator.upper()
                if isinstance(operator_query, str):
                    query = f"{query} {operator} {operator_query}"
        query_params = urlencode({"q": query, "type": search_type.lower()})
        print(query_params)
        return self.base_search(query_params)

# This class for wrangling received outputs
class TrackFeatureProcessor(object):
    track_js = None
    feat_js = None
    track_df = None
    feat_df = None
    df = None
    artists_df = None
    word = None
    word_df = None

    def __init__(self, track_js, feat_js, word, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.track_js = track_js
        self.feat_js = feat_js
        self.word = word

    def process_feats_track(self):
        self.process_features_json()
        self.process_track_json()
        # self.merge_track_features()

    def extract_artists_df(self):
        del(self.track_df["artists"])
        artists_cols = ["artist.id", "id", "artist.name"]
        self.artists_df = pd.json_normalize(
            self.track_js, "artists", meta="id", record_prefix="artist.")
        self.artists_df = self.clean_df(self.artists_df, artists_cols)

    def create_word_df(self):
        self.word_df = pd.DataFrame(
            {"word": self.word, "id": self.track_df["id"][0]},  index=[0])

    def process_features_json(self):
        our_features = ["danceability", "energy", "key", "loudness", "mode", "speechiness", "acousticness",
                        "instrumentalness", "liveness", "valence", "tempo", "id", "duration_ms", "time_signature"]
        self.feat_js = self.process_json(self.feat_js, our_features)
        self.feat_df = self.js_to_dataframe(self.feat_js)

    def process_track_json(self):
        our_features = ["album", "artists", "duration_ms",
                        "explicit", "id", "is_local", "name", "popularity"]
        album_features = ["album.name", "album.release_date"]
        cols_to_keep = our_features + album_features
        self.track_js = self.process_json(self.track_js, our_features)
        self.track_df = self.js_to_dataframe(self.track_js)
        self.track_df = self.clean_df(self.track_df, cols_to_keep)

    def merge_track_features(self):
        self.merged_df = pd.merge(
            self.track_df, self.feat_df, on='id', how='inner')

    def js_to_dataframe(self, processed_trjs):
        return pd.json_normalize(processed_trjs)

    def process_json(self, mjson, our_features):
        newj = {}
        for feat in our_features:
            newj[feat] = mjson[feat]
        return newj

    def clean_df(self, df_to_clean, cols_to_keep):
        return df_to_clean.loc[:, df_to_clean.columns.intersection(
            cols_to_keep)]

# Here we go - some demonstration


def runmeone(sometrackid="06AKEBrKUckW0KREUWRnvT", spotify=SpotifyAPI(client_id, client_secret)):
    af_resp = spotify.get_resource(
        sometrackid, resource_type='audio-features')
    tr_resp = spotify.get_resource(
        sometrackid, resource_type='tracks')
    processor = TrackFeatureProcessor(tr_resp, af_resp)
    processor.process_feats_track()
    processor.extract_artists_df()
    processor.merge_track_features()


def runmemore(spotify=SpotifyAPI(client_id, client_secret), q_words=["denial", "aggression"]):
    processors = []
    # loop through random words to get tracks for each
    for word in q_words:
        s_res = spotify.search(query=word, search_type="track")
        track_ids = []
        # most likely we will get several tracks per word,
        for track in s_res["tracks"]["items"]:
            track_ids.append(track["id"])

        # get tracks and audio features at once with the multiple resource method
        af_resps = spotify.get_resources(','.join(map(str, track_ids)), resource_type='audio-features')
        tr_resps = spotify.get_resources(','.join(map(str, track_ids)), resource_type='tracks')

        # create an array of processors with dataframes
        for i in range(len(tr_resps["tracks"])):
            processor = TrackFeatureProcessor(tr_resps["tracks"][i], af_resps["audio_features"][i], word)
            processor.process_feats_track()
            processor.extract_artists_df()
            processor.merge_track_features()
            processor.create_word_df()
            processors.append(processor)

    # merge all dataframes into one and save as CSV
    tracks_dfs = []
    artists_dfs = []
    word_df = []

    for processor in processors:
        tracks_dfs.append(processor.merged_df)
        artists_dfs.append(processor.artists_df)
        word_df.append(processor.word_df)

    tracks_df = pd.concat(tracks_dfs)
    artists_df = pd.concat(artists_dfs)
    words_df = pd.concat(word_df)

    tracks_df.to_csv(f"tracks-{int(time.time())}.csv", index=False)
    artists_df.to_csv(f"artists-{int(time.time())}.csv", index=False)
    words_df.to_csv(f"words-{int(time.time())}.csv", index=False)


# manytracks = spotify.get_resources(
#     "7ouMYWpwJ422jRcDASZB7P,4VqPOruhp5EdPBeR92t6lQ,2takcwOaAZWiXQijPHIx7B", resource_type='tracks')
# spotify = SpotifyAPI(client_id, client_secret)
# runmemore()

# Lets use true random words
r = RandomWords()
qw = r.get_random_words(limit=2)
print(qw)
runmemore(q_words=qw)
